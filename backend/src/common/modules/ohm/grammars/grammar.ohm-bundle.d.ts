// AUTOGENERATED FILE
// This file was generated from grammar.ohm by `ohm generateBundles`.

import {
    BaseActionDict,
    Grammar,
    IterationNode,
    Node,
    NonterminalNode,
    Semantics,
    TerminalNode,
} from "ohm-js";

export interface GrammarActionDict<T> extends BaseActionDict<T> {
    Chart?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    Number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    Number_add_plus?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    Number_add_minus?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    Number_add?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    Number_mul_mult?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    Number_mul_div?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    Number_mul?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    Number_parsed_parens?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Number_parsed?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    Number_other_redSum?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Number_other_redAvg?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Number_other_redMin?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Number_other_redMax?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Number_other_redMedian?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Number_other_aggrSum?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Number_other_aggrAvg?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Number_other_aggrMin?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Number_other_aggrMax?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Number_other_aggrMedian?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Number_other?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    number_fract?: (
        this: NonterminalNode,
        arg0: IterationNode,
        arg1: TerminalNode,
        arg2: IterationNode
    ) => T;
    number_whole?: (this: NonterminalNode, arg0: IterationNode) => T;
    number?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    NumberArr_plus_l?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    NumberArr_minus_l?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    NumberArr_mult_l?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    NumberArr_div_l?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    NumberArr_plus_r?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    NumberArr_minus_r?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    NumberArr_mult_r?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    NumberArr_div_r?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    NumberArr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    NumberArr_parsed_parens?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    NumberArr_parsed?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    NumberArr_other_aggrSum?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    NumberArr_other_aggrAvg?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    NumberArr_other_aggrMin?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    NumberArr_other_aggrMax?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    NumberArr_other_aggrMedian?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    NumberArr_other?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    ident_numberArr?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: IterationNode
    ) => T;
    ObjectArr_plus_l?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    ObjectArr_minus_l?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    ObjectArr_mult_l?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    ObjectArr_div_l?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    ObjectArr_plus_r?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    ObjectArr_minus_r?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    ObjectArr_mult_r?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    ObjectArr_div_r?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    ObjectArr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    ObjectArr_parsed_parens?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    ObjectArr_parsed?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    ident_objectArr?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: IterationNode
    ) => T;
    Object_plus_l?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    Object_minus_l?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    Object_mult_l?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    Object_div_l?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    Object_plus_r?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    Object_minus_r?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    Object_mult_r?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    Object_div_r?: (
        this: NonterminalNode,
        arg0: NonterminalNode,
        arg1: TerminalNode,
        arg2: NonterminalNode
    ) => T;
    Object?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    Object_parsed_parens?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Object_parsed?: (this: NonterminalNode, arg0: NonterminalNode) => T;
    Object_other_aggrSum?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Object_other_aggrMin?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Object_other_aggrMax?: (
        this: NonterminalNode,
        arg0: TerminalNode,
        arg1: NonterminalNode,
        arg2: TerminalNode
    ) => T;
    Object_other?: (this: NonterminalNode, arg0: NonterminalNode) => T;
}

export interface GrammarSemantics extends Semantics {
    addOperation<T>(name: string, actionDict: GrammarActionDict<T>): this;
    extendOperation<T>(name: string, actionDict: GrammarActionDict<T>): this;
    addAttribute<T>(name: string, actionDict: GrammarActionDict<T>): this;
    extendAttribute<T>(name: string, actionDict: GrammarActionDict<T>): this;
}

export interface GrammarGrammar extends Grammar {
    createSemantics(): GrammarSemantics;
    extendSemantics(superSemantics: GrammarSemantics): GrammarSemantics;
}

declare const grammar: GrammarGrammar;
export default grammar;
